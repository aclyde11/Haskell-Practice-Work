\documentclass[12pt]{article}


\usepackage{listings}
\usepackage{color}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amsthm,amssymb,graphicx,mathtools,tikz,hyperref}
\usetikzlibrary{positioning}
\usepackage{listings}
\newcommand{\n}{\mathbb{N}}
\newcommand{\z}{\mathbb{Z}}
\newcommand{\q}{\mathbb{Q}}
\newcommand{\cx}{\mathbb{C}}
\newcommand{\real}{\mathbb{R}}
\newcommand{\field}{\mathbb{F}}
\newcommand{\ita}[1]{\textit{#1}}
\newcommand{\com}[2]{#1\backslash#2}
\newcommand{\oneton}{\{1,2,3,...,n\}}
\newcommand\idea[1]{\begin{gather*}#1\end{gather*}}
\newcommand\ef{\ita{f} }
\newcommand\eff{\ita{f}}
\newcommand\proofs[1]{\begin{proof}#1\end{proof}}
\newcommand\inv[1]{#1^{-1}}
\newcommand\setb[1]{\{#1\}}
\newcommand\en{\ita{n }}
\newcommand{\vbrack}[1]{\langle #1\rangle}
\newcommand{\code}[1]{\texttt{#1}}


\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{exercise}[2][Exercise]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{reflection}[2][Reflection]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
 \hypersetup{
 colorlinks,
 linkcolor=blue
 }
\begin{document}
\date{}


\title{CMSC 161: Honors Introduction to Computer Programming}
\author{Austin Clyde\\Professor Chugh}

\maketitle
\section{Class 1}
\subsection{House Keeping}
\begin{itemize}
\item Daily assignments are to be turned in at the beginning of each lecture, on paper. Assignments marked by an astrik need to be done
\item Something else goes here. $x + \sigma$
\end{itemize}

\subsection{Introduction}
Haskell is:
\begin{itemize}
\item functional
\item pure
\item lazy
\end{itemize}
...and thats about all he told us.\\

\subsection{Online Notes}
\textbf{Functions} in haskell are by curried (though tuples can be used as well. So a function that in Java would like {\tt rate (distance, time)} will actually be written as {\tt rate distance time}. Haskell has built in {\tt curry} and {\tt uncurry} functions.


\section{Class 2}
\textbf{Functions} in Haskell only take one argument. So haskell left associates parenthesies {\tt $(((e_1 e_2) e_3) e_4)$}, so $e_1$ takes one single argument and returns another function that takes $e_3$. --This is a curried function. We could easily define the function to just take a single 3-tuple, which is just a single argument. Every function in Haskell is unary.\\

If we wanted to right associate parenthesies, we could use infix {\tt \$} to represent right associaitive parenthesies. \\ 
Since all functions take one argument, we can create a constant function {\tt one \_ = 1}, rather than using a variable that isn't referenced later {\tt one x = 1 }. \\

\subsection{Lists}
The most basic list is {\tt []}. We can on the fly define lists with commas, {\tt [1, 2, 3, 4]}. All values within the list must have the same type. One difference between a tuple and list is in management. Tuples are hard coded by size; lists are hard coded by type.\\

Lists can also be created by cons, which is right associtives. We can construct lists like {\tt [1, 2, 3]} by {\tt 1 : 2 : 3 : [] }. \\
Effectivly this makes lists have a base case of {\tt [] } and everything else is an inductive case.\\

The type of a list is defined once the first 'typed' element is cons onto the empty list.\\

Ranges can be generated by {\tt .. }, which is includisve. If you include a comma it might look for a pattern? Look this up or something.  \\

You can remove n elements from a list with {\tt take n list}. 




\section{Class 3}
(op m) == flip (op) m
(m op) == (op) m

\subsection{$\eta$ reduction}
For instance,
\begin{equation*}
  \begin{aligned}
    f x &= g x\\
    f &= g.
  \end{aligned}
\end{equation*}
Since $g$ is a fucntion already, we can smimply bind $f$ to that function. This is ~mostly~ a matter of style. Either $f x$ or $f$ work, but be consistent. Different oppertunites lend intself to different styles.

\subsection{Types}
For instance, the list $[]$ is a polymoprhic type. So [char] = [] char. \\

Numbers are intersting because they are a part of a type class \textbf{Num}. Hence, 10 is type Num but can also be type Int, Integer, or float. Types in the subset of the larger class can be casted, but Haskell will not allow you to check types.\\

The type expressions are basically the same and SML. Prenthesises for type expressions assoc to the right.

\section{Class 4 \& 5}
\subsection{Algebraic data tpypes}
Using the keyword {\tt data}, you can define your own type. i.e.\\
{\tt data Person = Student | Teacher}.\\
Just as functions are the name. \\
\subsection{Foldr]}
Take the code: {\tt 1:2:3:[] = f 1 (f 2 (f 3 init)) = 1`f`(2 `f` (3`f` init))}.

You can also write {\tt foldl} such that
\lstinputlisting[style=mystyle, firstline = 3, language=Haskell]{2c2.hs}





\end{document}